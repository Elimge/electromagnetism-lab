// src/lib/physics/biotSavart.ts
import * as THREE from "three";

// Physical constant: Vacuum permeability (μ₀) divided by 2π.
// // μ₀ = 4π * 10⁻⁷, so (μ₀ / 2π) = 2 * 10⁻⁷
const MU0 = 4 * Math.PI * 1e-7; 
const MU0_OVER_2PI = 2e-7; 

// /**
// * Calculates the magnetic field vector (B) at a point in space
// * generated by a current (I) in an infinite straight wire along the Y axis.
// * @param current - The current in Amps (can be positive or negative).
// * @param measurementPosition - The position (x, y, z) where the field is measured.
// * @returns A THREE.Vector3 representing the magnetic field B.
// */
// export function calculateBField(current: number, measurementPosition: THREE.Vector3): THREE.Vector3 {
//     // 1. Calculate the perpendicular distance (r) beetween the cable (axis Y) and the point. 
//     // The cable is in (0, y, 0), so, the distance in the XZ plane is sqrt(x² + z²)
//     const r = Math.sqrt(measurementPosition.x ** 2 + measurementPosition.z ** 2); 

//     // if we are in the center of the cable, the B is infinite.
//     // To avoid a ZeroDivision error, return a zero vector 
//     if (r === 0) {
//         return new THREE.Vector3(0, 0, 0);
//     }

//     // Calculate the magnitude of the magnetic field using the formula.
//     const bMagnitude = (MU0_OVER_2PI * current) / r;

//     // 3. Determine the direction of the field using the right-hand rule.
//     // The magnetic field forms circles around the wire in the XZ plane.
//     // The direction vector is always perpendicular to the radial position vector (x, 0, z).
//     // If the radial vector is (x, 0, z), the tangential vector is (-z, 0, x) or (z, 0, -x).
//     // For a positive current (upward, +Y), the correct direction is (z, 0, -x).
//     const bDirection = new THREE.Vector3(measurementPosition.z, 0, -measurementPosition.x).normalize();
    
//     // Combine magnitude and direction to obtain the final field vector.
//     const bFieldVector = bDirection.multiplyScalar(bMagnitude);

//     return bFieldVector; 
// }

/**
* Calculates the magnetic field vector (B) at a point in space
* generated by a current (I) in an infinite straight wire along the Y axis.
* @param current - The current in Amps (can be positive or negative).
* @param measurementPosition - The position (x, y, z) where the field is measured.
* @returns A THREE.Vector3 representing the magnetic field B.
*/
export function calculateWireBField(current: number, measurementPosition: THREE.Vector3): THREE.Vector3 {
    const r = Math.sqrt(measurementPosition.x ** 2 + measurementPosition.z ** 2); 
    if (r === 0) return new THREE.Vector3(0, 0, 0); 
    const bMagnitude = (MU0_OVER_2PI * current) / r; 
    const bDirection = new THREE.Vector3(measurementPosition.z, 0, -measurementPosition.x).normalize(); 
    return bDirection.multiplyScalar(bMagnitude);
}


// Function 2: Circular loop 
/**
* Calculates the magnetic field ONLY along the central axis (Y axis) of a circular loop.
* @param current - The current in Amps.
* @param radius - The radius of the loop.
* @param measurementPosition - The position where the field is measured.
*/
export function calculateLoopBField(current: number, radius: number, measurementPosition: THREE.Vector3): THREE.Vector3 {
    const y = measurementPosition.y; 
    const rSquared = radius * radius; 
    
    // Formula: B = (μ₀ * I * R²) / (2 * (y² + R²)^(3/2))
    const denominator = 2 * Math.pow(y * y + rSquared, 1.5);
    if (denominator === 0) return new THREE.Vector3(0, 0, 0); 

    const bMagnitude = (MU0 * current * rSquared) / denominator; 

    // On the axis, the field always point the direction +Y (or -Y if the current is negative).
    const bDirection = new THREE.Vector3(0, 1, 0);

    return bDirection.multiplyScalar(bMagnitude);
}

/**
* Calculates the magnetic field ONLY inside an ideal solenoid.
* @param current - The current in Amps.
* @param turns - The total number of turns.
* @param height - The total height of the solenoid.
* @param measurementPosition - The position where the field is measured.
*/
export function calculateSolenoidBField(current: number, turns: number, height: number, measurementPosition: THREE.Vector3): THREE.Vector3 {
    // Check if the point is inside the solenoid cylinder 
    const radius = Math.sqrt(measurementPosition.x ** 2 + measurementPosition.z ** 2);
    const isInside = radius < 1 && Math.abs(measurementPosition.y) < height / 2;

    if (!isInside) {
        return new THREE.Vector3(0, 0, 0); // The field outside the a ideal solenoid is zero. 
    }

    const turnsPerMeter = turns / height;  // n = N / L
    // Formula: B = μ₀ * n * I
    const bMagnitude = MU0 * turnsPerMeter * current;

    // The field inside is uniform and points the +Y direction.
    const bDirection = new THREE.Vector3(0, 1, 0); 

    return bDirection.multiplyScalar(bMagnitude); 
}